import { useCallback } from "react";
import { formatDataForExport } from "../utils/dataProcessor";

// export const useDataExport = () => {
//   /**
//    * Generic utility to trigger a file download in the browser.
//    */
//   const downloadFile = useCallback((content, fileName, contentType) => {
//     const blob = new Blob([content], { type: contentType });
//     const url = window.URL.createObjectURL(blob);
//     const link = document.createElement("a");
//     link.href = url;
//     link.download = fileName;
//     document.body.appendChild(link);
//     link.click();
//     document.body.removeChild(link);
//     window.URL.revokeObjectURL(url);
//   }, []);

//   /**
//    * Handles the export process for various formats.
//    * @param {string} format - The desired format ('CSV', 'JSON', 'NetCDF', 'PDF').
//    * @param {object} data - The chart data object.
//    * @param {string} title - The title for the export.
//    * @param {string} messageContent - The AI's message content for the PDF report.
//    */
//   const exportData = useCallback(
//     async (format, data, title, messageContent) => {
//       const fileNameBase = title.replace(/\s+/g, "_").toLowerCase();

//       switch (format) {
//         case "CSV": {
//           const content = formatDataForExport(data, "csv");
//           downloadFile(
//             content,
//             `${fileNameBase}.csv`,
//             "text/csv;charset=utf-t;"
//           );
//           break;
//         }
//         case "JSON": {
//           const content = formatDataForExport(data, "json");
//           downloadFile(content, `${fileNameBase}.json`, "application/json");
//           break;
//         }
//         case "NetCDF": {
//           // Note: This uses the simplified JSON representation from dataFormatter
//           const content = formatDataForExport(data, "netcdf");
//           downloadFile(content, `${fileNameBase}.nc.json`, "application/json");
//           break;
//         }
//         case "PDF": {
//           // Generates an HTML report that the user can print to PDF.
//           // This avoids adding heavy dependencies like jsPDF and html2canvas.
//           const htmlContent = `
//             <!DOCTYPE html>
//             <html>
//               <head>
//                 <title>${title}</title>
//                 <style>
//                   body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 2rem; color: #e2e8f0; background-color: #0f172a; }
//                   h1, h2 { color: #00bcd4; border-bottom: 1px solid #334155; padding-bottom: 0.5rem; }
//                   p { line-height: 1.6; }
//                   .container { max-width: 800px; margin: auto; }
//                   .chart-placeholder { border: 2px dashed #334155; padding: 2rem; text-align: center; margin: 2rem 0; background: #1e293b; border-radius: 8px; }
//                   pre { background-color: #1e293b; padding: 1rem; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; }
//                 </style>
//               </head>
//               <body>
//                 <div class="container">
//                   <h1>${title}</h1>
//                   <p><em>Generated by FloatChat AI on ${new Date().toLocaleString()}</em></p>
//                   <h2>Analysis</h2>
//                   <p>${messageContent.replace(/\n/g, "<br>")}</p>
//                   <div class="chart-placeholder">
//                     <p><strong>Chart Visualization Area</strong></p>
//                     <p>(A static image of the chart would be embedded here in a full implementation. You can print this page to PDF.)</p>
//                   </div>
//                   <h2>Raw Data (JSON)</h2>
//                   <pre><code>${formatDataForExport(data, "json")}</code></pre>
//                 </div>
//               </body>
//             </html>
//           `;
//           downloadFile(htmlContent, `${fileNameBase}_report.html`, "text/html");
//           break;
//         }
//         default:
//           console.warn(`Unsupported export format: ${format}`);
//       }
//     },
//     [downloadFile]
//   );

//   return { exportData };
// };

export const useDataExport = () => {
  /**
   * Generic utility to trigger a file download in the browser.
   */
  const downloadFile = useCallback((content, fileName, contentType) => {
    const blob = new Blob([content], { type: contentType });
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = fileName;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    window.URL.revokeObjectURL(url);
  }, []);

  /**
   * Handles the export process for various formats.
   * @param {string} format - The desired format ('CSV', 'JSON', 'NetCDF', 'PDF').
   * @param {object} data - The chart data object.
   * @param {string} title - The title for the export.
   * @param {string} messageContent - The AI's message content for the PDF report.
   */
  const exportData = useCallback(
    async (format, data, title, messageContent) => {
      const fileNameBase = title.replace(/\s+/g, "_").toLowerCase();

      switch (format) {
        case "CSV": {
          const content = formatDataForExport(data, "csv");
          downloadFile(
            content,
            `${fileNameBase}.csv`,
            "text/csv;charset=utf-8;"
          );
          break;
        }
        case "JSON": {
          const content = formatDataForExport(data, "json");
          downloadFile(content, `${fileNameBase}.json`, "application/json");
          break;
        }
        case "NetCDF": {
          // Note: This uses the simplified JSON representation from dataFormatter
          const content = formatDataForExport(data, "netcdf");
          downloadFile(content, `${fileNameBase}.nc.json`, "application/json");
          break;
        }
        case "PDF": {
          // Generates an HTML report that the user can print to PDF.
          // This has been updated to remove the raw data section.
          const htmlContent = `
            <!DOCTYPE html>
            <html>
              <head>
                <title>${title}</title>
                <style>
                  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 2rem; color: #e2e8f0; background-color: #0f172a; }
                  h1, h2 { color: #00bcd4; border-bottom: 1px solid #334155; padding-bottom: 0.5rem; }
                  p { line-height: 1.6; }
                  .container { max-width: 800px; margin: auto; }
                  .chart-placeholder { 
                    border: 2px dashed #334155; 
                    padding: 2rem; 
                    text-align: center; 
                    margin: 2rem 0; 
                    background: #1e293b; 
                    border-radius: 8px; 
                  }
                </style>
              </head>
              <body>
                <div class="container">
                  <h1>${title}</h1>
                  <p><em>Generated by FloatChat AI on ${new Date().toLocaleString()}</em></p>
                  
                  <h2>Analysis</h2>
                  <p>${messageContent.replace(/\n/g, "<br>")}</p>

                  <div class="chart-placeholder">
                    <p><strong>Chart Visualization Area</strong></p>
                    <p>(A static image of the chart would be embedded here in a full implementation. You can print this page to PDF.)</p>
                  </div>

                </div>
              </body>
            </html>
          `;
          downloadFile(htmlContent, `${fileNameBase}_report.html`, "text/html");
          break;
        }
        default:
          console.warn(`Unsupported export format: ${format}`);
      }
    },
    [downloadFile]
  );

  return { exportData };
};





